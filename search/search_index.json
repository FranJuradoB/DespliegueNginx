{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"README-Practica2/","title":"\u00cdNDICE:","text":""},{"location":"README-Practica2/#0-introduccion","title":"0. Introducci\u00f3n","text":""},{"location":"README-Practica2/#1-instalacion-servidor-web-nginx","title":"1. Instalaci\u00f3n servidor web Nginx","text":""},{"location":"README-Practica2/#2-creacion-directorio-del-sitio-web","title":"2. Creaci\u00f3n directorio del sitio web","text":""},{"location":"README-Practica2/#3-configuracion-de-servidor-web-nginx","title":"3. Configuraci\u00f3n de servidor web Nginx","text":""},{"location":"README-Practica2/#31-comprobaciones-uso-correcto-y-comprobar-registros","title":"3.1. Comprobaciones: Uso correcto y comprobar registros","text":""},{"location":"README-Practica2/#32-ftp-transferir-archivos","title":"3.2. FTP: Transferir archivos","text":""},{"location":"README-Practica2/#introduccion","title":"Introducci\u00f3n","text":"<p>Vamos a instalar el servidor Nginx en nuestra Debian creada anteriormente para configurarla y posteriormente agregar nuestro sitio web. Se probar\u00e1 tambi\u00e9n el m\u00e9todo de transferencia de datos con FTP.</p>"},{"location":"README-Practica2/#instalacion-servidor-nginx","title":"Instalaci\u00f3n servidor Nginx","text":"<p>Lo primero de todo er\u00e1 actualizar el repositorio con el siguiente comando:</p> <p></p> <p>Y acto seguido se instalar\u00e1 el paquete de Nginx:</p> <p></p> <p>Podemos comprobar que se ha instalado correctamente y que est\u00e1 funcionando si introducimos:</p> <p></p>"},{"location":"README-Practica2/#creacion-del-directorio-del-sitio-web","title":"Creaci\u00f3n del directorio del sitio web","text":"<p>Al igual que en otros servidores, como en Apache, necesitamos un directorio organizado en carpetas para tener nuestro sitio web. Tal y como se explica en los manuales, suele estar en /var/www  , salvo que se haya modificado previamente. Por tanto, nos disponemos a crear en la siguiente ruta nuestra carpeta para el dominio web: La llamaremos \"fjurado\" y ella contendr\u00e1 el subdirectorio \"html\".</p> <p></p> <p>Como paso intermedio, en nuestro caso no tenemos instalado Git y no podremos realizar el siguiente paso, con lo cual haremos: </p> <p></p> <p>Despu\u00e9s de instalar Git, en dicha carpeta tendremos que clonar el siguiente repositorio: </p> <p>https://github.com/cloudacademy/static-website-example</p> <p></p> <p>Es necesario cambiar la propiedad al directorio www-data, ya que es el usuario con el cual Nginx se ejecuta. Lo haremos de la siguiente forma:</p> <p></p> <p></p> <p>Introduciendo la ip de nuestra m\u00e1quina de Debian en el navegador, podemos comprobar que todo marcha correctamente, ya que nos saldr\u00e1 algo igual a lo siguiente:</p> <p></p>"},{"location":"README-Practica2/#configuracion-servidor-nginx","title":"Configuraci\u00f3n Servidor Nginx","text":"<p>A continuaci\u00f3n debemos configurar nuestro servidor. Para ello tenemos dos directorios importantes: sites-available(sitios que contiene el servidor) y sites-enabled(archivos de configuraci\u00f3n de los sitios previamente habilitados). Dentro de \"sites-available\" tendremos el directorio de nuestro sitio web. Creamos un nuevo bloque con las directivas correctas, en vez de modificar el predeterminado, usando nuestro editor de texto preferido, en mi caso con \"nano\":</p> <p></p> <p></p> <p>Inclu\u00edmos el path de nuestro sitio web, y modificaremos en la directiva server_name a\u00f1adiendo nuestro nombre.</p> <p>Posteriormente vamos a crear un archivo simb\u00f3lico entre este archivo y el de sitios que est\u00e1n habilitados con el siguiente comando:</p> <p>sudo ln -s /etc/nginx/sites-available/nombre_web /etc/nginx/sites-enabled/</p> <p></p> <p>Y reiniciamos el servidor para que se apliquen los cambios:</p> <p></p>"},{"location":"README-Practica2/#comprobaciones","title":"Comprobaciones","text":"<p>Al no disponer de un servidor DNS, deberemos introducir la ip de forma manual. Lo primero de todo, y aunque ya tengamos la ip de nuestra m\u00e1quina de Debian de pr\u00e1cticas anteriores, usaremos el siguiente comando para volver a disponer de ella:</p> <p></p> <p>Habr\u00e1 que editar el archivo /etc/hosts mediante un sudo nano:</p> <p></p> <p></p> <p>Y tenemos que a\u00f1adirle la ip de la siguiente forma, seguida del nombre web:</p> <p></p>"},{"location":"README-Practica2/#comprobacion-registros","title":"Comprobaci\u00f3n registros","text":"<p>A continuaci\u00f3n vamos a comprobar que los registros se den de forma correcta, tanto los que se producen bien y sin problemas al realizarse una solicitud al servidor, como el log de cada error que aparezca.</p> <p>Tenemos dos rutas principales: /var/log/nginx/access.log   y  /var/log/nginx/error.log He preferido usar la opci\u00f3n \"tail\" en vez de cat, para poder obtener el log en tiempo real y as\u00ed comprobar de una mejor forma el funcionamiento:</p> <p></p> <p>Como se puede observar, se realiza la petici\u00f3n de forma correcta. En cambio, para el log de error no nos notifica ning\u00fan error y debemos salir del proceso con ctrl + Z.</p> <p></p>"},{"location":"README-Practica2/#configurar-servidor-sftp","title":"Configurar servidor SFTP","text":"<p>Dada la teor\u00eda de la pr\u00e1ctica conforme a este sistema de transferencia de archivos, vamos a actualizar e instalar en primer lugar el vsftpd (es un servidor FTP ligero y seguro) en nuestra m\u00e1quina:</p> <p></p> <p></p> <p>Crearemos una carpeta en nuestro directorio /home:</p> <p></p> <p>Y ahora habr\u00e1 que configurar el vsftpd de la siguiente forma:      1. Lo primero que haremos ser\u00e1 a\u00f1adir los certificados de seguridad necesarios para a\u00f1adir una capa de cifrado a nuestra conexi\u00f3n:</p> <p></p> <pre><code>2. Entraremos al archivo de configuraci\u00f3n con \"nano\":\n</code></pre> <p></p> <pre><code>Y tenemos que buscar las siguientes l\u00edneas:\n</code></pre> <p></p> <pre><code>para sustituirlas por las siguientes:\n</code></pre> <p></p> <p>Volveremos a reiniciar el servicio para que se adapten los cambios:</p> <p></p>"},{"location":"README-Practica2/#descargamos-filezilla-y-establecemos-conexion","title":"Descargamos Filezilla y establecemos conexi\u00f3n","text":"<p>Debemos descargar el cliente de filezilla para nuestra m\u00e1quina anfitriona, y en ella veremos una interfaz como la siguiente, donde tenemos que introducir la ip del servidor (en este caso nuestra m\u00e1quina virtual Debian, que es donde tenemos alojado Nginx):</p> <p></p> <p>Como podemos observar, solo nos salen los datos de nuestra m\u00e1quina f\u00edsica, con sus directorios disponibles. Despues de a\u00f1adir la direcci\u00f3n ip, nuestro usuario y contrase\u00f1a, asignamos el puerto 21, porque al ser una transferencia privada no tenemos ning\u00fan tipo de riesgo. En caso contrario y de forma opcional tambi\u00e9n se puede usar el puerto 22 para una transferencia m\u00e1s segura:</p> <p></p> <p></p> <p>Tras aceptar ya tenemos la conexi\u00f3n establecida como podemos observar y podemos enviar cualquier archivo a trav\u00e9s de Filezilla. Nos aparece a la derecha el directorio de nuestra Debian.</p> <p></p> <p>Hemos probado un archivo pdf para comprobar que funciona correctamente.</p>"},{"location":"README-Practica2/#ponemos-en-funcionamiento-la-pagina-web","title":"Ponemos en funcionamiento la p\u00e1gina web","text":"<p>Accedemos desde la m\u00e1quina f\u00edsica al navegador.</p> <p></p> <p>Aceptamos los riesgos y nos sale ya nuestra p\u00e1gina web:</p> <p></p>"},{"location":"PRACTICA-AMP/PRACTICA-AMP/","title":"PR\u00c1CTICA DE AMPLIACI\u00d3N","text":""},{"location":"PRACTICA-AMP/PRACTICA-AMP/#configuracion-de-la-practica-y-objetivo","title":"Configuraci\u00f3n de la pr\u00e1ctica y objetivo","text":"<p>El prop\u00f3sito principal de esta pr\u00e1ctica es implementar y configurar un servidor web utilizando Nginx, aprovechando su capacidad para gestionar hosts virtuales. Esto permitir\u00e1 alojar m\u00faltiples sitios web en un solo servidor, optimizando recursos y simplificando la administraci\u00f3n del sistema. Cada host virtual estar\u00e1 configurado de manera que apunte al directorio public_html correspondiente a distintos usuarios del sistema operativo Debian. Al hacerlo, se habilitar\u00e1 un entorno donde cada usuario del sistema pueda gestionar y personalizar su propio sitio web desde su carpeta personal, sin interferir con los sitios de otros usuarios. Este enfoque es especialmente \u00fatil en entornos compartidos, como servidores de desarrollo, acad\u00e9micos o de peque\u00f1as empresas, donde un \u00fanico servidor f\u00edsico o virtual puede atender las necesidades de m\u00faltiples usuarios y sitios web.</p> <p>Usaremos una conexi\u00f3n mediante SSH :</p> <p></p>"},{"location":"PRACTICA-AMP/PRACTICA-AMP/#documentacion","title":"Documentaci\u00f3n","text":""},{"location":"PRACTICA-AMP/PRACTICA-AMP/#1-instalacion-nginx","title":"1. Instalaci\u00f3n Nginx","text":"<p>Creamos una nueva m\u00e1quina virtual destinada para esta pr\u00e1ctica:</p> <p></p> <p>Tenemos que actualizar previamente la lista de paquetes de los repositorios del sistema para luego instalar las versiones m\u00e1s recientes con el comando siguiente:</p> <p><code>sudo apt update &amp;&amp; sudo apt upgrade -y</code></p> <p></p> <p>Y nos dispondremos a instalar nginx con el siguiente comando: <code>sudo apt install nginx -y</code></p> <p></p> <p>Y para ver que se ha instalado correctamente y que su estado es activo, usaremos el ya conocido comando <code>sudo systemctl status nginx</code></p> <p></p>"},{"location":"PRACTICA-AMP/PRACTICA-AMP/#2-creacion-de-usuarios-del-sistema","title":"2. Creaci\u00f3n de usuarios del sistema","text":"<p>Para este segundo paso tendremos que crear dos usuarios del sistema operativo. Usaremos los siguientes comandos para ello:</p> <p><code>sudo adduser &lt;nombre_usuario&gt;</code></p> <p>Usaremos el nombre <code>usuario1</code> y <code>usuario2</code> para no complicarnos.</p> <p></p> <p></p> <p>Tendremos ya los 3 usuarios en el sistema:</p> <p></p>"},{"location":"PRACTICA-AMP/PRACTICA-AMP/#3-estructura-de-carpetas-y-archivos","title":"3. Estructura de carpetas y Archivos","text":"<ol> <li>El primer paso que deberemos hacer es crear la carpeta <code>public_html</code> en los directorios de cada usuario con el comando <code>sudo mkdir /home/nombreUsuario/public_html</code></li> </ol> <ol> <li>Ahora tenemos que asignar los permisos a cada usuario creado sobre su directorio con el comando <code>sudo chown -R nombreUsuario:nombreUsuario /home/nombreUsuario/public_html</code> y <code>sudo chmod 755 /home/nombreUsuario</code></li> </ol> <ol> <li>Ahora como \u00faltimo paso tenemos que crear una p\u00e1gina web de prueba en el directorio <code>public_html</code> de los respectivos usuarios. Por eso cambiaremos de usuario con <code>su nombreUsuario</code> y creamos el archivo de la p\u00e1gina web con el comando <code>echo \"&lt;h1&gt;Bienvenido al sitio de nombreUsuario&lt;/h1&gt;\" &gt; /home/nombreUsuario/public_html/index.html</code>. Tendremos que repetir dicho comando con los dos usuarios.</li> </ol>"},{"location":"PRACTICA-AMP/PRACTICA-AMP/#4-configuracion-basica-de-nginx-y-creacion-de-host-virtuales","title":"4. Configuraci\u00f3n b\u00e1sica de Nginx y creaci\u00f3n de host virtuales","text":"<p>En este cuarto paso tenemos que borrar los sitios habilitados en nuestro servidor Nginx para evitar problemas. Si hemos realizado una instalaci\u00f3n solo tendremos que borrar el <code>default</code> con <code>sudo rm /etc/nginx/sites-enabled/default</code>.</p> <p></p> <p>Ahora crearemos el siguiente archivo de configuraci\u00f3n para los hosts virtuales en el directorio sites-available de cada uno de los usuarios:</p> <p><code>sudo nano /etc/nginx/sites-available/usuario1</code></p> <p><code>sudo nano /etc/nginx/sites-available/usuario2</code></p> <p></p> <p></p> <p>Habilitaremos ahora los enlaces simb\u00f3licos de ambas p\u00e1ginas con <code>sudo ln -s /etc/nginx/sites-available/nombreUsuarios /etc/nginx/sites-enabled/</code></p> <p></p> <p>Probamos que la configuraci\u00f3n es toda correcta y no presenta ning\u00fan error, para ello usamos el comando <code>sudo nginx -t</code></p> <p></p> <p>Como \u00faltimo paso vamos a reiniciar Nginx con <code>sudo systemctl restart nginx</code> y luego probamos con <code>sudo systemctl status nginx</code> que va todo bien.</p> <p></p>"},{"location":"PRACTICA-AMP/PRACTICA-AMP/#https","title":"HTTPS","text":"<pre><code>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\n    -keyout /etc/nginx/ssl/nginx-selfsigned.key \\\n    -out /etc/nginx/ssl/nginx-selfsigned.crt\n</code></pre> <p>Modificamos los archivos de configuraci\u00f3n:</p> <p>Empezamos por la ruta <code>hosts</code> de la m\u00e1quina anfitriona de windows:</p> <p></p> <pre><code>    server {\n    listen 443 ssl;\n    server_name usuario1.local;\n\n    ssl_certificate /etc/nginx/ssl/nginx-selfsigned.crt;\n    ssl_certificate_key /etc/nginx/ssl/nginx-selfsigned.key;\n\n    root /home/usuario1/public_html;\n    index index.html;\n\n    location / {\n        try_files $uri $uri/ =404;\n    }\n}\n</code></pre> <p>Modificamos el archivo de configuraci\u00f3n de nginx de la ruta <code>/etc/nginx/sites-available/usuarioX</code> con ambos usuarios.</p> <p></p> <p>Modificaremos tambi\u00e9n el tema de los permisos en sus respectivas carpetas para que el usuario <code>www-data</code>, que es el que se encarga de ejecutar los procesos web pueda ejecutarlo.</p> <p></p> <p>Hacemos lo mismo con el <code>usuario2</code>. </p> <p>Y ya por fin accedemos a ambos directorios para ver los resultados en el navegador:</p> <p><code>Bienvenida del usuario1</code></p> <p></p> <p><code>Bienvenida del usuario2</code></p> <p></p>"},{"location":"PRACTICA2-2/practica2-1/","title":"Requisitos previos","text":"<p>Debemos tener la pr\u00e1ctica anterior correctamente para poder seguir con \u00e9sta segunda parte.</p>"},{"location":"PRACTICA2-2/practica2-1/#introduccion","title":"Introducci\u00f3n","text":"<p>La autenticaci\u00f3n de acceso b\u00e1sico en transacciones HTTP permite que un navegador o cliente env\u00ede credenciales (usuario y contrase\u00f1a) al solicitar una p\u00e1gina al servidor. Es el m\u00e9todo m\u00e1s simple de autenticaci\u00f3n web, definido en la especificaci\u00f3n HTTP. Aunque cumple su funci\u00f3n, tiene serias fallas de seguridad y no es recomendable en muchas situaciones, ya que no utiliza cookies, identificadores de sesi\u00f3n ni una p\u00e1gina de inicio de sesi\u00f3n.</p>"},{"location":"PRACTICA2-2/practica2-1/#instalacion-de-paquetes","title":"Instalaci\u00f3n de paquetes","text":"<p>Lo primero que debemos hacer es si el siguiente paquete est\u00e1 instalado correctamente con el siguiente comando: - dpkg -l | grep openssl</p> <p></p> <p>Y si no lo estuviera, se instala.</p>"},{"location":"PRACTICA2-2/practica2-1/#creacion-de-usuarios-y-contrasenas","title":"Creaci\u00f3n de usuarios y contrase\u00f1as","text":"<p>Vamos a crear varios usuarios y contrase\u00f1as para el acceso web a nuestra p\u00e1gina web. Para ello crearemos un archivo oculto llamado \"./htpasswd\" en el directorio de configuraci\u00f3n /etc/nginx donde guardaremos nuestros usuarios y contrase\u00f1as:</p> <p></p> <p>Crearemos un password cifrado para el usuario:</p> <p></p> <p>Nos pedir\u00e1 verificarlas tambi\u00e9n.</p> <p>Y con el comando cat podemos comprobar que nos lo ha almacenado correctamente:</p> <p></p> <p>Haremos lo mismo y crearemos un usuario extra con mi nombre y otro con el apellido:</p> <p></p> <p></p> <p>Y mostramos que todo ha ido correctamente con el siguiente comando: - cat /etc/nginx/.htpasswd</p> <p></p>"},{"location":"PRACTICA2-2/practica2-1/#configuracion-servidor-nginx","title":"Configuraci\u00f3n servidor Nginx","text":"<p>Ahora tenemos que editar la configuraci\u00f3n b\u00e1sica del server block para aplicar la restricci\u00f3n de acceso. Usaremos <code>sudo nano /etc/nginx/sites-available/fjurado</code></p> <p>Y a\u00f1adimos las siguientes l\u00edneas:</p> <p></p> <p>Y reiniciamos:</p> <p><code>sudo systemctl restart nginx</code></p>"},{"location":"PRACTICA2-2/practica2-1/#pruebas-nueva-configuracion","title":"Pruebas Nueva configuraci\u00f3n","text":"<ul> <li>COMPROBACI\u00d3N 1:</li> </ul> <p>Al entrar al sitio web, despu\u00e9s de haber realizado todos los cambios de arriba, podremos comprobar que nos permite el acceso:</p> <p></p> <ul> <li>COMPROBACI\u00d3N 2:</li> </ul> <p>Si cancelamos la autenticaci\u00f3n en vez de introducir los datos nos da el siguiente error:</p> <p></p>"},{"location":"PRACTICA2-2/practica2-1/#tareas","title":"Tareas","text":"<p>Vamos a intentar entrar usando el login equivocado, usando otros usuarios, y observamos que el log de error nos lo notifica.</p> <p>A continuaci\u00f3n vemos que el usuario v\u00e1lido nos lo notifica en el log:</p> <p></p> <p>En la ruta <code>sudo nano /etc/nginx/sites-available/nombre_web</code> modificaremos algunos valores, a\u00f1adiendo una nueva \"location:</p> <p></p> <p>Vamos a usar \u00e9sta vez una ruta hacia contact.html , para de esa forma poder entrar al sitio web, pero que no se pueda acceder a dicha p\u00e1gina salvo excepciones.</p> <p> </p> <p>Nos pide login para dicha zona de nuestro sitio web. Hemos duplicado y modificado el index.html para realizar la pr\u00e1ctca.</p> <p>Y reiniciamos el servicio <code>sudo systemctl restart nginx</code>.</p>"},{"location":"PRACTICA2-2/practica2-1/#combinacion-de-la-autenticacion-basica-con-la-restriccion-por-ip","title":"Combinaci\u00f3n de la autenticaci\u00f3n b\u00e1sica con la restriccion por IP","text":""},{"location":"PRACTICA2-2/practica2-1/#tareas_1","title":"Tareas","text":"<ul> <li>Tarea 1:</li> </ul> <p>Entramos en el archivo de configuraci\u00f3n y a\u00f1adimos el \"deny\" para denegar el acceso a dicha IP, y el \"allow\" para permitir dichas IP's. Tambi\u00e9n \"deny all\" para denegar el acceso al resto de IP's.</p> <ul> <li>Tarea 2: Ahora usamos nuestra ip de la m\u00e1quina anfitriona y denegamos su acceso.</li> </ul> <p></p> <p></p> <p>Y comprobamos que no podemos entrar.</p> <p></p> <p>Para que sea necesaria tanto la IP como el login, deberemos usar <code>satisfy all</code></p> <p></p>"},{"location":"PRACTICA2-2/practica2-1/#cuestiones-finales","title":"Cuestiones finales","text":"<p>En este caso no se podr\u00eda acceder porque al estar la opci\u00f3n de satisfy all, tanto ip como la introducci\u00f3n de usuario es obligatorio que se cumplan ambas condiciones.</p> <p></p> <p>En este caso la opci\u00f3n \"deny all\" est\u00e1 m\u00e1s arriba que el allow correspondiente a la ip que intenta acceder, y da igual que se introduzca bien el usuario y contrase\u00f1a, porque deniega todos los accesos.</p> <p></p> <p>En este caso s\u00ed que se podr\u00e1 acceder porque la opci\u00f3n \"satisfy any\" valora dos condiciones, ip correcta e introducci\u00f3n de usuario y contrase\u00f1a, y aunque la ip se deniegue la correcta introducci\u00f3n del login prevalece por encima.</p> <p></p> <p>Crear\u00edamos un usuario o los que quisi\u00e9ramos y usar\u00edamos el siguiente c\u00f3digo:</p> <p>location / {     try_files $uri $uri/ =404; }</p> <p>location /Proyectos {     auth_basic \"\u00c1rea restringida - Proyectos\";     auth_basic_user_file /etc/nginx/conf.d/htpasswd_proyectos; }</p> <p>Aqu\u00ed se configura el acceso restringido para el directorio /Proyectos usando la autenticaci\u00f3n b\u00e1sica con un archivo de contrase\u00f1as (htpasswd). As\u00ed solo quienes tengan el usuario y la contrase\u00f1a correcta podr\u00e1n acceder a /Proyectos.</p>"},{"location":"PRACTICA2-3/Pr%C3%A1ctica2-3/","title":"\u00cdndice","text":"<ol> <li>Nginx Servidor</li> <li>Nginx Proxy Inverso</li> <li>Comprobaciones</li> </ol>"},{"location":"PRACTICA2-3/Pr%C3%A1ctica2-3/#nginx-servidor","title":"Nginx Servidor","text":"<p>Como paso previo a trabajar con esta pr\u00e1ctica, vamos a realizar una clonaci\u00f3n de la m\u00e1quina virtual, para usar la nueva como servidor proxy. Para ello debemos especificar que tenga otra MAC, de lo contrario nos dar\u00e1 problemas con la IP.</p> <p> </p> <p>Primero se debe cambiar el nombre de nuestra web a webserver, lo que implica que tenemos que cambiar el archivo de configuraci\u00f3n y eliminar el enlace simb\u00f3lico previo para crear uno nuevo con el nombre de archivo.</p> <p></p> <p>Eliminamos enlace simb\u00f3lico y creamos uno nuevo:</p> <p></p> <p></p> <p>Cambiamos con sudo nano /etc/nginx/sites-available/webserver las directivas, a\u00f1adiendo el puerto 8080 y toda configuraci\u00f3n con el nuevo nombre.</p> <p></p> <p>Despu\u00e9s reiniciamos Nginx.</p>"},{"location":"PRACTICA2-3/Pr%C3%A1ctica2-3/#nginx-proxy-inverso","title":"Nginx Proxy Inverso","text":"<p>En el host de windows se cambia la IP por la de la nueva m\u00e1quina que va a actuar de proxy y se le cambia el nombre.</p> <p></p> <p>Tambi\u00e9n debemos modificar el nuevo archivo en /etc/nginx/sites-available , a\u00f1adiendo la directiva pass_proxy con su nueva direcci\u00f3n y puerto 8080.</p> <p>Despu\u00e9s tendremos que modificar el hosts en la m\u00e1quina con la ip del servidor:</p> <p></p>"},{"location":"PRACTICA2-3/Pr%C3%A1ctica2-3/#comprobaciones","title":"Comprobaciones","text":"<p>Tras una serie de problemas, tuvimos que cambiarle el nombre a servidor 1, e intentamos entrar a la web desde la m\u00e1quina. Ahora hacemos la prueba al entrar a la web desde el proxy, y vemos que todo funciona correctamente: </p> <p>Podemos comprobar que en el acceso al log nos lo notifica correctamente.</p> <p></p> <p>Y podemos comprobar en las herramientas de desarrollador, que nos notifica correctamente la petici\u00f3n con el c\u00f3digo 200 Ok.</p> <p></p>"},{"location":"PRACTICA2-4/READMEpractica2-4/","title":"PR\u00c1CTICA 2.4 - Balanceo de carga con proxy inverso en Nginx","text":"<p>Esta pr\u00e1ctica presenta el concepto de balanceo de carga usando un proxy inverso con Nginx. Aprenderemos a distribuir el tr\u00e1fico entre m\u00faltiples servidores para mejorar la disponibilidad y eficiencia de un servicio web. El prop\u00f3sito es configurar un proxy inverso que dirija las solicitudes a dos servidores distintos, asegurando el acceso incluso si uno de ellos deja de funcionar. Tambi\u00e9n exploraremos diversos m\u00e9todos de balanceo para identificar el m\u00e1s adecuado seg\u00fan cada situaci\u00f3n.</p>"},{"location":"PRACTICA2-4/READMEpractica2-4/#configuraciones","title":"Configuraciones","text":"<p>Se configurar\u00e1n servidores web Nginx en dos m\u00e1quinas con Debian y se reutilizar\u00e1 el proxy inverso Nginx. - Cada servidor web mostrar\u00e1 un sitio espec\u00edfico. - El servidor web 2 deber\u00e1 contar con una IP asignada de forma est\u00e1tica mediante DHCP. - El proxy inverso se ajustar\u00e1 para llevar a cabo el balanceo de carga.</p> <p>Las peticiones HTTP se realizar\u00e1n desde un navegador en nuestra m\u00e1quina anfitriona.</p> <p>Al acceder a http://balanceo, se observar\u00e1 c\u00f3mo las solicitudes se distribuyen entre el servidor 1 y el servidor 2.</p> <p><code>Desactivaremos los sitios web de las pr\u00e1cticas anteriores para que podamos trabajar:</code></p> <p></p> <p>Volvemos a crear el link simb\u00f3lico y reiniciamos Nginx.</p> <p></p>"},{"location":"PRACTICA2-4/READMEpractica2-4/#nginx-servidor-web-1","title":"Nginx Servidor web 1","text":"<p>Vamos a mantener la m\u00e1quina debian de la pr\u00e1ctica anterior, la de <code>webserver</code>. Seguir\u00e1 escuchando el puerto 8080 y se le a\u00f1adir\u00e1 su correspondiente cabecera.</p> <p></p> <p>Una vez hecho \u00e9sto, vamos a proceder a hacerle una clonaci\u00f3n de la m\u00e1quina virtual para utilizarla como servidor 2.</p>"},{"location":"PRACTICA2-4/READMEpractica2-4/#nginx-servidor-web-2","title":"Nginx Servidor web 2","text":"<p>Aqu\u00ed nos serviremos de la m\u00e1quina virtual clonada, como mencionamos arriba. Ser\u00e1 la webserver2, y tendremos que modificar el nombre en el apartado de <code>servername</code> para ponerle <code>webserver2</code>.  Seguir\u00e1 igual que la otra, escuchando al puerto 8080 y le modificaremos la cabecera para que sea distinto al otro servidor.</p> <p></p> <p>Guardamos cambios y pasamos a la siguiente fase.</p>"},{"location":"PRACTICA2-4/READMEpractica2-4/#configuracion-nginx-inverso","title":"Configuraci\u00f3n Nginx inverso","text":"<p>Ahora vamos a configurar el servidor proxy de la pr\u00e1ctica anterior para que \u00e9ste realice el reparto correspondiente de peticiones. Para ello deberemos modificar en el archivo de configuraci\u00f3n un bloque <code>upstring</code> donde hagamos referencia con el nombre a ambos servidores, ya correctamente configurados.</p> <p></p> <p>Tambi\u00e9n debemos modificar el archivo correspondiente en hosts para a\u00f1adir la ip de los servers. En su respectiva ruta <code>/etc/hosts</code>:</p> <p></p>"},{"location":"PRACTICA2-4/READMEpractica2-4/#comprobaciones","title":"Comprobaciones","text":"<p>Al acceder al sitio web, a trav\u00e9s de la URL que pusimos <code>ejemplo-proxy.com</code> podemos comprobar que no hay ning\u00fan problema. Si refrescamos la ventana nos damos cuenta que cada vez nos pone una cabecera distinta, que era la finalidad de nuestra pr\u00e1ctica, alternar y balancear la carga.</p> <p></p> <p>Aqu\u00ed tenemos la cabecera del primer webserver, y al refrescar obtenemos la del otro, abort\u00e1ndonos la primera.</p> <p></p> <p>Si pausamos uno de los servidores, mediante el comando <code>sudo systemctl stop nginx</code>, podemos comprobar que sigue direccionando al servidor que a\u00fan permanece activo. \u00c9sto es un buen salvoconducto para evitar que los usuarios puedan seguir accediendo a nuestras p\u00e1ginas web en caso de fallo t\u00e9cnico.</p> <p></p> <p>Como podemos ver, al parar el primer server, no impide que no podamos acceder. Esto es aplicable aunque se parase el otro servidor, pues ambos tienen el mismo peso.</p>"},{"location":"PRACTICA2-4/READMEpractica2-4/#cuestiones-finales","title":"Cuestiones finales","text":""},{"location":"PRACTICA2-4/READMEpractica2-4/#cuestion-1","title":"Cuesti\u00f3n 1","text":"<p>Los m\u00e9todos de balanceo de carga m\u00e1s utilizados que he encontrado son los siguientes:</p> <ol> <li> <p>Round Robin: Este m\u00e9todo asigna las solicitudes a los servidores de manera secuencial, es decir, va turnando las peticiones entre los servidores disponibles uno tras otro.</p> </li> <li> <p>Least Connections: Con este m\u00e9todo, la solicitud se dirige al servidor que tenga la menor cantidad de conexiones activas en ese momento, lo que permite equilibrar la carga seg\u00fan el uso actual de cada servidor.</p> </li> <li> <p>IP Hash: Aqu\u00ed se utiliza la direcci\u00f3n IP del cliente para determinar el servidor al que se enviar\u00e1n sus solicitudes. Esto asegura que el mismo cliente sea dirigido siempre al mismo servidor, \u00fatil para mantener sesiones o preferencias de usuario.</p> </li> </ol>"},{"location":"PRACTICA2-4/READMEpractica2-4/#cuestion-2","title":"Cuesti\u00f3n 2","text":"<p>El bloque de configuraci\u00f3n <code>server</code> es el encargado de redirigir el tr\u00e1fico hacia los <code>backend_hosts</code>, que representan el grupo de servidores definidos previamente en el bloque <code>upstream</code>. Este bloque <code>upstream</code> establece c\u00f3mo se manejar\u00e1n las redirecciones y qu\u00e9 m\u00e9todo de balanceo de carga se usar\u00e1. Aqu\u00ed es donde se a\u00f1adir\u00e1n los servidores, especificando primero la IP del servidor, seguida del puerto al que este escucha, separado por dos puntos.</p>"},{"location":"PRACTICA2-4/READMEpractica2-4/#cuestion-3","title":"Cuesti\u00f3n 3","text":"<p>Para configurar el balanceo de carga, debemos seguir dos pasos principales:</p> <ol> <li> <p>Definir el bloque <code>upstream</code>: En este bloque, se incluir\u00e1n las IP y los puertos de los servidores que recibir\u00e1n las solicitudes, configurando as\u00ed el grupo de servidores para el balanceo.</p> </li> <li> <p>Configurar el bloque <code>location</code>: Dentro de este bloque, utilizaremos la directiva <code>proxy_pass</code> para redirigir las solicitudes entrantes hacia los servidores que hemos definido en el bloque <code>upstream</code>.</p> </li> </ol>"},{"location":"PRACTICA3-1/","title":"PR\u00c1CTICA 3.1: Instalaci\u00f3n de Tomcat","text":""},{"location":"PRACTICA3-1/#instalacion-de-tomcat","title":"Instalaci\u00f3n de Tomcat","text":"<ol> <li>Instalaci\u00f3n de Java En el caso de que no lo tengamos instalado Java, instalaremos el jdk</li> </ol> <p><code>sudo apt install default-jre</code></p> <p></p> <p>Podemos comprobar la versi\u00f3n instalada con el siguiente comando: </p> <p><code>java -version</code></p> <p></p> <ol> <li>Tomcat</li> </ol> <p>Instalaremos la versi\u00f3n 10 de Tomcat</p> <p><code>sudo apt install tomcat10 tomcat10-admin</code></p> <p></p> <p>Posteriormente tendremos que crear el usuario para Tomcat. Y para ello, lo que debemos modificar es el archivo <code>tomcat-users.xml</code> </p> <p>y quedar\u00e1 de la siguiente forma: </p> <p></p> <p>Cuando ya hayamos configurado el archivo procederemos a reiniciar el servicio Tomcat con el siguiente comando: <code>sudo systemctl restart tomcat</code>. Y comprobaremos que el servicio se ha iniciado correctamente usando <code>sudo systemctl status tomcat</code>. Deber\u00e1 aparecernos algo como lo siguiente:</p> <p></p>"},{"location":"PRACTICA3-1/#despliegue-manual-mediante-la-gui-de-administracion","title":"Despliegue manual mediante la GUI de administraci\u00f3n","text":"<p>Accederemos a la direcci\u00f3n ```http://localhost:8080/nombre_usuario/html y nos aparecer\u00e1 algo as\u00ed:</p> <p></p> <p></p> <p>Cuando hayamos hecho la comprobaci\u00f3n de que Tomcat se ha instalado correctamente, procederemos a intentar desplegar un archivo <code>.war</code> en Tomcat. Hay que aclarar que el archivo correspondiente al <code>.war</code> que se nos facilit\u00f3 tiene errores y realizaremos la prueba con otro archivo <code>.war</code> de ejemplo.</p> <p>Desde este enlace lo descargaremos: <code>https://tomcat.apache.org/tomcat-6.0-doc/appdev/sample/</code></p> <p>Lo seleccionamos y lo desplegamos:</p> <p></p> <p></p> <p>Y accedemos para ver que est\u00e1 correctamente desplegado:</p> <p></p>"},{"location":"PRACTICA3-1/#despliegue-con-maven","title":"Despliegue con Maven","text":""},{"location":"PRACTICA3-1/#instalacion-de-maven","title":"Instalaci\u00f3n de Maven","text":"<p>Para el despliegue con Maven, tendremos que instalar Maven al igual que hicimos arriba con Tomcat:</p> <p></p> <p>Podemos consultar la versi\u00f3n instalada con el comando: <code>nvm --v</code></p>"},{"location":"PRACTICA3-1/#configuracion-de-maven","title":"Configuraci\u00f3n de Maven","text":"<p>Ahora lo que tenemos que hacer es a\u00f1adir un nuevo usuario al archivo <code>tomcat-users.xml</code> para poder desplegar con Maven, y el archivo quedar\u00e1 ahora de la siguiente forma:</p> <p></p> <p>Una vez que tengamos hecho eso, tendremos que configurar Maven de la siguiente manera: Tenemos que modificar el archivo <code>settings.xml</code>. Quedar\u00e1 de tal forma:</p> <p></p> <p>Ahora clonaremos el repositorio de ejemplo que se nos ha facilitado y lo desplegaremos con Maven:</p> <p></p> <p>Cambiamos de rama para trabajar mejor: </p> <p></p> <p>Ahora tenemos que editar el archivo <code>pom.xml</code> para a\u00f1adirle la configuraci\u00f3n. </p> <p></p> <p>Tendr\u00e1 que quedar as\u00ed:</p> <p></p>"},{"location":"PRACTICA3-1/#despliegue","title":"Despliegue","text":"<p>Usaremos el comando <code>`mvn tomcat7:deploy</code> para desplegarlo:</p> <p></p> <p>Y al acceder a la direcci\u00f3n <code>http://localhost:8080/nombre_usuario/</code> nos debe aparecer algo como lo siguiente:</p> <p></p> <p>Y si se accede al archivo nos debe aparecer lo siguiente:</p> <p></p>"},{"location":"PRACTICA3-1/#cuestiones","title":"CUESTIONES","text":"<p>Hab\u00e9is visto que los archivos de configuraci\u00f3n que hemos tocado contienen contrase\u00f1as en texto plano, por lo que cualquiera con acceso a ellos obtendr\u00eda las credenciales de nuestras herramientas. En principio esto representa un gran riesgo de seguridad, \u00bfsabr\u00edas razonar o averig\u00fcar por qu\u00e9 esto est\u00e1 dise\u00f1ado de esta forma?</p> <p>Guardar contrase\u00f1as en texto plano dentro de archivos de configuraci\u00f3n no es seguro, aunque a menudo se recurre a ello por motivos pr\u00e1cticos. Esto puede simplificar el acceso durante el desarrollo, garantizar compatibilidad con herramientas obsoletas o incluso mejorar el rendimiento en sistemas cerrados con bajos requerimientos de seguridad. Sin embargo, en entornos de producci\u00f3n es fundamental optar por alternativas m\u00e1s seguras, como el uso de cifrado o gestores de secretos, para proteger las credenciales adecuadamente.</p>"},{"location":"PRACTICA3-2/","title":"Practica 3-2. Instalacion de Node.js Express y test de la primera aplicaci\u00f3n.","text":"<p>Para empezar con esta pr\u00e1ctica, debemos de parar nuestro servicio de Tomcat ya que nos podr\u00eda ocasionar problemas. Para ello:</p> <p><code>sudo systemctl stop tomcat10</code></p> <p></p> <p>Una vez realizado, procedemos a instalar mediante el siguiente comando.</p> <p><code>sudo apt -y install nodejs npm</code></p> <p></p> <p>Cuando lo tengamos instalado, deberemos de instalar tambien Express. Para ello haremos uso del siguiente comando:</p> <p><code>sudo npm install -g express</code></p> <p></p> <p>Ahora, una vez que hayamos terminado de instalar todo lo necesario, procedemos con el despliegue de nuestra apliaci\u00f3n. Despliegue de aplicaci\u00f3n de manera local.</p> <p>Empezaremos clonando nuestro repositorio, del cual haremos el despliegue. <code>git clone https://github.com/MehedilslamRipon/Shopping-Cart-Application</code></p> <p></p> <p>Y accederemos a la carpeta.</p> <p><code>cd Shopping-Cart-Application</code></p> <p>Una vez dentro, debemos instalar las librer\u00edas necesarias para que nuestra aplicaci\u00f3n funcione correctamente.</p> <p><code>npm install</code></p> <p></p> <p></p> <p>Y haremos uso del siguiente comando para que no nos d\u00e9 el error sh: 1: nodemon: not found.</p> <p><code>npm install nodemon --save--dev</code></p> <p>Y desplegamos nuestra aplicaci\u00f3n.</p> <p></p> <p>Y hacemos la comprobaci\u00f3n de que accede correctamente.</p> <p></p>"},{"location":"PRACTICA3-2/#practica-34-despliegue-de-una-aplicacion-una-aplicacion-react-en-netlify-paas","title":"Pr\u00e1ctica 3.4: Despliegue de una aplicaci\u00f3n una aplicaci\u00f3n React en Netlify (PaaS)","text":"<p>Creaci\u00f3n de nuestra aplicaci\u00f3n</p> <p>Lo primero es crear los siguientes archivos en un mismo directorio para crear la aplicaci\u00f3n:</p> <p> </p> <p>Ahora se crea el package.json con npm init.</p> <p></p> <p></p> <p>Y se comprueba qque funciona ejecutando node aplicacion.js y comprob\u00e1ndolo con la ip de la m\u00e1quina y el puerto que por defecto es el 8080.</p> <p></p>"},{"location":"PRACTICA3-2/#aplicacion-para-netlify","title":"Aplicaci\u00f3n para Netlify","text":"<p>Se clona el repositorio con el siguiente comando: <code>git clone https://github.com/StackAbuse/color-shades-generator</code></p> <p></p> <p>Lo primero es registrarse en NETLIFY con el correo y sin usar el Github.</p> <p></p> <p>Luego se crea un token de acceso y se copia dicho token.</p> <p></p> <p></p> <p></p>"},{"location":"PRACTICA3-2/#despliegue-mediante-cli","title":"Despliegue mediante CLI","text":"<p>Se instala el CLI de NETLIFY.</p> <p></p> <p>Se guarda el token de antes para acceder, mediante una variable.</p> <p></p> <p>Se hace el login con el comando siguiente:</p> <p></p> <p>Dentro del proyecto se instala las librer\u00edas.</p> <p></p> <p>Se ejecuta el proyecto.</p> <p></p> <p>Se hace un pre despliegue ahora con netlify deploy.</p> <p></p> <p>Y finalmente se despliega con netlify deploy --prod.</p> <p></p> <p>Se comprueba el despliegue.</p> <p></p> <p></p>"},{"location":"PRACTICA3-2/#despliegue-mediante-conexion-con-github","title":"Despliegue mediante conexi\u00f3n con Github","text":"<p>Lo primero es eliminar la p\u00e1gina creada en netlify y el repositorio que se habia clonado.</p> <p></p> <p></p> <p>Se descarga las fuentes en formato .zip.</p> <p></p> <p></p> <p></p> <p>Se crea un nuevo repositorio.</p> <p></p> <p>Se a\u00f1ade el contenido de la carpeta al repositorio.</p> <p></p> <p></p> <p>Ahora se procede a conectar el repositorio con NETLIFY, se autoriza todo y luego se selecciona el repositorio creado antes.</p> <p></p> <p></p> <p>Seleccionamos el repositorio que nos interesa y se comprueba que el nombre est\u00e1 disponible.</p> <p></p> <p>Se introducen los siguientes comandos en los campos de datos y se le da a deploy.</p> <p></p> <p></p> <p></p> <p>Ahora se accede a la carpeta public y se modifica el archivo robot.txt, se pone el nombre en disallow, se sube al repositorio con un commit y ya estar\u00eda hecho.</p> <p></p>"},{"location":"PRACTICA3-5/PRACTICA3-5/","title":"Pr\u00e1ctica 3.5: Despliegue de una aplicaci\u00f3n Flask (Python)","text":""},{"location":"PRACTICA3-5/PRACTICA3-5/#indice","title":"\u00cdndice","text":"<ol> <li>Prerrequisitos</li> <li>Procedimiento Completo Para el Despliegue</li> <li>Cuesti\u00f3n</li> </ol>"},{"location":"PRACTICA3-5/PRACTICA3-5/#prerrequisitos","title":"Prerrequisitos","text":"<p>Para esta pr\u00e1ctica se deben tener las siguientes herramientas instaladas en el sistema:  <code>- Nginx - Gunicorn - Pipenv</code></p>"},{"location":"PRACTICA3-5/PRACTICA3-5/#procedimiento-completo-para-el-despliegue","title":"Procedimiento Completo Para el Despliegue","text":"<p>Como primer paso, se ha de instalar el gestor de paquetes de Python pip: <code>Python3-pip</code></p> <p></p> <p>Una vez instalado pip, se ha de instalar pipenv:</p> <p></p> <p>Se crea un directorio para la aplicaci\u00f3n. Al crearla se apreciar\u00e1 que los permisos pertenecen a root. Para cambiarlos se ha de ejecutar el comando siguiente:</p> <p></p> <p>Para ser cambiados se ejecutar\u00e1 el siguiente comando: </p> <p></p> <p>Y se le cambiar\u00e1n los permisos para que al iniciar Nginx no haya problemas: </p> <p></p> <p>Ahora, dentro del directorio creado con anterioridad se crear\u00e1 el archivo oculto .env</p> <p></p> <p>En el archivo .env se a\u00f1adir\u00e1n las siguientes lineas: </p> <p></p> <p>Se iniciar\u00e1 el entorno virtual y Pipenv cargar\u00e1 las dependencias del archivo .env:</p> <p></p> <p>Como se aprecia en la utima l\u00ednea de la captura, aparece el nombre de nuestro entorno virtual, lo cual significa que se ha iniciado correctamente.</p> <p>Hecho esto, se instalar\u00e1n las dependencias para la aplicaci\u00f3n: </p> <p></p> <p>Se crear\u00e1n los archivos app.py y wsgi.py que contendr\u00e1n los siguientes codigos:</p> <p></p> <p></p> <p>Se probar\u00e1 la aplicaci\u00f3n con el comando siguiente: </p> <p></p> <p>Si todo ha ido bien, si se accede al enlace proporcionado se podr\u00e1 ver la aplicaci\u00f3n funcionando: </p> <p></p> <p>Se comprobar\u00e1 ahora que Gunicorn funciona correctamente: </p> <p></p> <p>Se tomar\u00e1 nota del path desde donde se ejectuta Gunicorn, para ello se ejecutar\u00e1 el siiguinte comandodentro de nuestro entorno virtual: </p> <p></p> <p>Se saldr\u00e1 del entorno virtual con <code>deactivate</code></p> <p>Se iniciar\u00e1 Nginx si no estaba iniciado de antemano y se comprobar\u00e1 que sigue funcionando perfectamente:</p> <p></p> <p>Se crear\u00e1 un archivo de configuraci\u00f3n para que systemd ejecute Gunicorn como otro servicio mas: </p> <p>Ahora se habilitar\u00e1 el servicio y se comprobar\u00e1 que se ha iniciado correctamente: </p> <p></p> <p>Ahora se modifiar\u00e1 el archivo de configuraci\u00f3n de Nginx de la siguiente manera: Nginx</p> <p></p> <p>Se crear\u00e1 el enlace simb\u00f3lico para que Nginx pueda acceder a los archivos de la aplicaci\u00f3n: </p> <p></p> <p>Se comptobar\u00e1 que la configuraci\u00f3n de Nginx es correcta:</p> <p></p> <p>Se editar\u00e1 el archivo hosts para que se pueda acceder a la aplicaci\u00f3n desde el navegador:</p> <p></p> <p>Se comprobar\u00e1 que la aplicaci\u00f3n funciona correctamente en el navegador: </p> <p></p> <p>Ahora se deber\u00e1 repetir el proceso para un repositorio que se clonar\u00e1 de GitHub:</p> <p></p> <p>Se crear\u00e1 el archivo .env con las variables de entorno necesarias: </p> <p></p> <p>Se cambiar\u00e1n los permisos del directorio y los propietarios: </p> <p></p> <p>Se iniciliazar\u00e1 el entorno virtual: </p> <p></p> <p>Y se probar\u00e1 la aplicaci\u00f3n: </p> <p></p> <p>Se comprobar\u00e1 que funciona correctamente, que como hicimos antes, el Gunicorn funciona adecuadamente.</p> <p></p>"},{"location":"PRACTICA3-5/PRACTICA3-5/#cuestion","title":"Cuestion","text":"<p>Un servidor WSGI (Web Server Gateway Interface) act\u00faa como intermediario entre aplicaciones web escritas en Python y servidores web como Apache o Nginx, traduciendo solicitudes HTTP en datos procesables por Python y devolviendo respuestas al cliente. Permite compatibilidad entre frameworks, facilita el despliegue en producci\u00f3n y mejora el manejo de m\u00faltiples solicitudes concurrentes de manera eficiente</p>"},{"location":"PRACTICA4-1/PRACTICA4-1/","title":"Pr\u00e1ctica 4-1 Configuraci\u00f3n de un servidor DNS","text":"<p>0. Paso previo: Conexi\u00f3n por SSH 1. Instalaci\u00f3n de servidor DNS 2. Configuraci\u00f3n 3. Configuraci\u00f3n del archivo named.conf.options 4. Configuraci\u00f3n del archivo named.conf.local 5. Configuraci\u00f3n del archivo db.deaw.es 6. Creaci\u00f3n del archivo de zona para la resoluci\u00f3n inversa 7. Comprobaci\u00f3n de la configuraci\u00f3n 8. Comprobaci\u00f3n del funcionamiento (resoluciones y de las consultas) 9. Cuestiones Finales</p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#0-paso-previo-conexion-por-ssh","title":"0. Paso previo: Conexi\u00f3n por SSH","text":"<p>Como paso previo a la instalaci\u00f3n podemos y deber\u00edamos conectarnos por SSH a nuestra m\u00e1quina f\u00edsica en todas las pr\u00e1cticas. Podemos hacerlo de esta forma: </p> <p></p> <p>Otra posible opci\u00f3n es configurar desde VirtualBox la m\u00e1quina virtual, usando el modo <code>NAT</code> en la secci\u00f3n <code>Red</code>. Configuramos en la secci\u00f3n avanzada el <code>Reenv\u00edo de puertos</code>. Y agregamos una nueva regla: </p> <pre><code>Anfitri\u00f3n: 127.0.0.1 (IP de la m\u00e1quina host)\nPuerto anfitri\u00f3n: 2222 (o cualquier puerto disponible)\nInvitado: IP de su m\u00e1quina virtual\nPuerto invitado: 22\n</code></pre> <p>Es necesario tener instalado el servidor SSH y funcionando en la m\u00e1quina virtual. Se puede instalar con <code>sudo apt-get install openssh-server</code></p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#1-instalacion-de-servidor-dns","title":"1. Instalaci\u00f3n de servidor DNS","text":"<p>Lo primero que debemos hacer es instalar ell servidor DNS en el servidor de pr\u00e1cticas. Para ello, nos lo vamos a instalar con el siguiente comando:</p> <pre><code>sudo apt-get install bind9 bind9utils bind9-doc\n</code></pre> <p></p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#2-configuracion","title":"2. Configuraci\u00f3n","text":"<p>Ahora, debemos editar el correspondiente archivo de configuraci\u00f3n de Bind para que podamos usar IPv4, que es el que nos interesa. Por tanto tewnemos que usar el comando <code>sudo nano /etc/default/named</code> Y le a\u00f1adimos en la l\u00ednea donde tenemos OPTIONS el valor <code>-u bind -4</code></p> <p></p> <p>Para comprobar que la configuraci\u00f3n del servidor DNS es correcta, comprobaremos el archivo correspondiente a <code>/etc/bind/named.conf</code></p> <p></p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#3-configuracion-del-archivo-namedconfoptions","title":"3. Configuraci\u00f3n del archivo named.conf.options","text":"<p>Ahora como paso previo y tal y como nos recomienda el repositorio de <code>https://raul-profesor.github.io/</code> vamos a realizarle una copia de seguridad al archivo que vamos a modificar y que nos interesa tenerlo como posible punto de recuperaci\u00f3n en caso de que tengamos alg\u00fan problema.</p> <p>Por eso tenemos que usar el siguiente comando en nuestra terminal: <code>sudo cp /etc/bind/named.conf.options /etc/bind/named.conf.options.backup</code>. </p> <p></p> <p>Una vez que ya hemos hecho el <code>backup</code> continuaremos con los siguientes pasos de la pr\u00e1ctica. Ahora lo que toca es editar el archivo <code>named.conf.options</code> con el comando: <code>sudo nano /etc/bind/named.conf.options</code></p> <p>Lo que haremos es limitar el acceso a peticiones recursivas al servidor en el archivo para los hosts que nos interesen.  Para eso, debemos agregar la siguiente l\u00ednea de c\u00f3digo al archivo: <code>acl confiables { 192.168.X.0/24};</code> Nuestra IP de la m\u00e1quina del servidor es <code>192.168.116.161 /24</code>, por lo tanto tendr\u00edamos que coger el valor 116 en la X.</p> <p></p> <p>Y despu\u00e9s de los forwarders tenemos que agregar lo siguiente: <code>allow-recursion { confiables; };</code> <code>allow-transfer { none; };</code> <code>listen-on port 53{192.168.X.X}</code> <code>recursion yes</code></p> <p>Y quitamos <code>listen-on-v6</code> , comentando la l\u00ednea por si nos hiciera falta en el futuro.</p> <p></p> <p>Y ahora vamos a comprobar si la configuraci\u00f3n introducida es correcta con el siguiente comando: <code>sudo named-checkconf</code></p> <p></p> <p>Y ahora para curarnos en salud, reiniciamos y comprobamos que el servicio marcha correctamente: </p> <p></p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#4-configuracion-del-archivo-namedconflocal","title":"4. Configuraci\u00f3n del archivo named.conf.local","text":"<p>En este archivo vamos a configurar las zonas, y para esta pr\u00e1ctica declaramos la zona deaw.es. Mediante el comando <code>sudo nano /etc/bind/named.conf.local</code> y a\u00f1adimos:</p> <pre><code>zone \"deaw.es\" {\n    type master;\n    file \"/etc/bind/db.deaw.es\";\n};\n</code></pre> <p></p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#5-configuracion-del-archivo-dbdeawes","title":"5. Configuraci\u00f3n del archivo db.deaw.es","text":"<p>Ahora vamos a crear el archivo <code>db.deaw.es</code> en la ruta <code>/etc/bind/</code>.</p> <p>Y le tenemos que a\u00f1adir todo lo siguiente:</p> <pre><code>@       IN      SOA     debian.deaw.es. admin.deaw.es. (\n                        2022112001 ;Serial\n                        3306       ;Refresh\n                        1800       ;Retry\n                        604800     ;Expire\n                        86400      ;Minimun TTL\n                        )\n\n        IN NS debian.deaw.es.\n\ndebian  IN A 192.168.116.161\n</code></pre> <p></p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#6-creacion-del-archivo-de-zona-para-la-resolucion-inversa","title":"6. Creaci\u00f3n del archivo de zona para la resoluci\u00f3n inversa","text":"<p>Aqu\u00ed tendremos que entrar en el archivo <code>named.conf.local</code> y debemos introducir las zonas de la misma forma que hicimos con la resoluci\u00f3n directa. A continuaci\u00f3n crearemos un archivo para la resoluci\u00f3n inversa. </p> <p></p> <p>\u00c9ste ser\u00eda el archivo correspondiente a la configuraci\u00f3n de la zona inversa.</p> <p>Tenemos que crear el archivo de zona para la resoluci\u00f3n inversa, que se llamar\u00e1 <code>db.1.168.192</code>, y lo configuramos de la siguiente manera:</p> <p></p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#7-comprobacion-de-la-configuracion","title":"7. Comprobaci\u00f3n de la configuraci\u00f3n","text":"<p>En este s\u00e9ptimo punto vamos a encargarnos de las comprobaciones correspondientes a las configuraciones que hemos realizado. Para ello usaremos dos comandos: <code>sudo named-checkzone db.deaw.es db.1.168.192</code> y al rev\u00e9s <code>sudo named-checkzone db.1.168.192 db.deaw.es</code>. De esta forma deberemos obtener el OK con sus respectivos datos.</p> <p></p> <p>Vemos que funciona correctamente, reiniciamos el servicio <code>sudo systemctl restart named</code> y vemos si funciona.</p> <p></p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#8-comprobacion-del-funcionamiento-resoluciones-y-de-las-consultas","title":"8. Comprobaci\u00f3n del funcionamiento (resoluciones y de las consultas)","text":"<p>Ahora vamos a establecer el cliente, y vamos a usar otra m\u00e1quina virtual Debian para ello (podemos tambi\u00e9n usar nuestra m\u00e1quina f\u00edsica anfitriona). En ella vamos a configurar el archivo <code>/etc/resolv.conf</code> de \u00e9sta m\u00e1quina poni\u00e9ndole la direcci\u00f3n IP del servidor DNS. Tiene que quedar de esta forma: </p> <p></p> <p>Despu\u00e9s ya podemos comprobar la resoluci\u00f3n directa e inversa, para estar seguros de que funcionan de forma correcta y no hemos tenido ning\u00fan error. Hay que ejecutar el comando <code>dig debian.deaw.es</code> , <code>dig -x 192.168.116.161</code> (usando la IP de la m\u00e1quina virtual que act\u00faa de servidor).</p> <p></p> <p></p> <p>Por \u00faltimo usamos el comando <code>nslookup</code> para realizar una consulta al sistema DNS y obtener la correspondiente informaci\u00f3n que nos ayude a verificar si hay alg\u00fan problema de red.</p> <p></p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#9-cuestiones-finales","title":"9. Cuestiones Finales","text":""},{"location":"PRACTICA4-1/PRACTICA4-1/#cuestion-1-que-pasara-si-un-cliente-de-una-red-diferente-a-la-tuya-intenta-hacer-uso-de-tu-dns-de-alguna-manera-le-funcionara-por-que-en-que-parte-de-la-configuracion-puede-verse","title":"Cuesti\u00f3n 1: \u00bfQu\u00e9 pasar\u00e1 si un cliente de una red diferente a la tuya intenta hacer uso de tu DNS de alguna manera, le funcionar\u00e1? \u00bfPor qu\u00e9, en qu\u00e9 parte de la configuraci\u00f3n puede verse?","text":"<p>Si un cliente de una red diferente intenta usar tu DNS, probablemente no funcionar\u00e1 (no deber\u00eda funcionar). Esto se debe a la configuraci\u00f3n de la ACL (Lista de Control de Acceso) que restringe las consultas a hosts espec\u00edficos. Puede verse en la directiva <code>allow-recursion {confiables;};</code></p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#cuestion-2-por-que-tenemos-que-permitir-las-consultas-recursivas-en-la-configuracion","title":"Cuesti\u00f3n 2: \u00bfPor qu\u00e9 tenemos que permitir las consultas recursivas en la configuraci\u00f3n?","text":"<p>Permitimos las consultas recursivas en la configuraci\u00f3n para que el servidor DNS pueda realizar b\u00fasquedas completas y proporcionar respuestas definitivas a las consultas de los clientes autorizados</p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#cuestion-3-el-servidor-dns-que-acabais-de-montar-es-autoritativo-por-que","title":"Cuesti\u00f3n 3: \u00bfEl servidor DNS que acab\u00e1is de montar, es autoritativo? \u00bfPor qu\u00e9?","text":"<p>Se han definido zonas primarias con <code>`\"type master;\"</code>. El servidor DNS que se ha montado es autoritativo para las zonas que se han configurado en \u00e9l. Es autoritativo porque contiene los registros de recursos originales para esas zonas espec\u00edficas. </p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#cuestion-4-donde-podemos-encontrar-la-directiva-origin-y-para-que-sirve","title":"Cuesti\u00f3n 4: \u00bfD\u00f3nde podemos encontrar la directiva $ORIGIN y para qu\u00e9 sirve?","text":"<p>La directiva $ORIGIN se encuentra en el archivo de zona DNS. Sirve para especificar el dominio base para los nombres de host en esa zona, permitiendo usar nombres relativos en los registros.</p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#cuestion-5-una-zona-es-identica-a-un-dominio","title":"Cuesti\u00f3n 5: \u00bfUna zona es id\u00e9ntica a un dominio?","text":"<p>Una zona no es id\u00e9ntica a un dominio. Una zona es una porci\u00f3n del espacio de nombres de dominio que se administra como una unidad, mientras que un dominio es una estructura jer\u00e1rquica en el sistema de nombres.</p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#cuestion-6-pueden-editarse-los-archivos-de-zona-de-un-servidor-esclavosecundario","title":"Cuesti\u00f3n 6: \u00bfPueden editarse los archivos de zona de un servidor esclavo/secundario?","text":"<p>No, los archivos de zona de un servidor esclavo/secundario no deben editarse directamente. Estos se actualizan autom\u00e1ticamente mediante transferencias de zona desde el servidor maestro.</p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#cuestion-7-por-que-podria-querer-tener-mas-de-un-servidor-esclavo-para-una-misma-zona","title":"Cuesti\u00f3n 7: \u00bfPor qu\u00e9 podr\u00eda querer tener m\u00e1s de un servidor esclavo para una misma zona?","text":"<p>Tener m\u00e1s de un servidor esclavo para una misma zona proporciona redundancia, mejora la distribuci\u00f3n de carga y aumenta la disponibilidad del servicio DNS.</p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#cuestion-8-cuantos-servidores-raiz-existen","title":"Cuesti\u00f3n 8: \u00bfCu\u00e1ntos servidores ra\u00edz existen?","text":"<p>Hay 13 servidores ra\u00edz de la A a la M.</p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#cuestion-9-que-es-una-consulta-iterativa-de-referencia","title":"Cuesti\u00f3n 9: \u00bfQu\u00e9 es una consulta iterativa de referencia?","text":"<p>Una consulta iterativa de referencia es un proceso donde un servidor DNS responde a una consulta con la mejor informaci\u00f3n que tiene, generalmente apuntando a otro servidor DNS que puede tener m\u00e1s informaci\u00f3n sobre la consulta.</p>"},{"location":"PRACTICA4-1/PRACTICA4-1/#cuestion-10-en-una-resolucion-inversa-a-que-nombre-se-mapearia-la-direccion-ip-172163456","title":"Cuesti\u00f3n 10: En una resoluci\u00f3n inversa, \u00bfa qu\u00e9 nombre se mapear\u00eda la direcci\u00f3n IP 172.16.34.56?","text":"<p>En una resoluci\u00f3n inversa, la direcci\u00f3n IP 172.16.34.56 se mapear\u00eda a un nombre de dominio en el formato \"56.34.16.172.in-addr.arpa\"</p>"},{"location":"PRACTICA6-3/","title":"Pr\u00e1ctica 6.3 - Despliegue de servidores web con usuarios autenticados mediante LDAP usando Docker y docker-compose","text":""},{"location":"PRACTICA6-3/#despliegue-con-docker-de-nginx-demonio-de-autenticacion-ldap-openldap","title":"Despliegue con Docker de NGINX + demonio de autenticaci\u00f3n LDAP + OpenLDAP","text":"<p>Empezamos creando los archivos necesarios para la pr\u00e1ctica.  Es importante comprobar el arbol de documentos, en mi caso he tenido que instalar <code>tree</code>.</p> <p></p> <p></p> <p>Dentro del directorio app se deber\u00e1 crear un archivo index.html con el siguiente contenido. Lo hacemos sin usar el comando <code>nano</code></p> <p></p> <p></p> <p>Tras hacer esto creamos el archivo ldap_nginx.conf y su configuraci\u00f3n:</p> <pre><code>$ cat &lt;&lt; EOF &gt; conf/ldap_nginx.conf\n    server {\n    listen 8082;\n\n    location = / {\n        auth_request /auth-proxy;\n    }\n\n    location = /auth-proxy {\n        internal;\n\n        proxy_pass http://nginx-ldap:8888;\n\n        # URL y puerto para conectarse al servidor LDAP\n        proxy_set_header X-Ldap-URL \"ldap://openldap:1389\";\n\n        # Base DN\n        proxy_set_header X-Ldap-BaseDN \"dc=example,dc=org\";\n\n        # Bind DN\n        proxy_set_header X-Ldap-BindDN \"cn=admin,dc=example,dc=org\";\n\n        # Bind password\n        proxy_set_header X-Ldap-BindPass \"adminpassword\";\n    }\n}\nEOF\n</code></pre> <p></p> <p>En la configuraci\u00f3n anterior se ha establecido que Nginx escuche en el puerto 8082 para no tener problemas de que est\u00e9 ocupado. Adem\u00e1s, se ha configurado una autenticaci\u00f3n para el directorio /auth-proxy, especificando la URL del servidor OpenLDAP (usando el nombre del contenedor Docker), el DN base para las b\u00fasquedas y las credenciales de acceso para realizar las consultas.</p> <p>Hecho esto, se crear\u00e1 un archivo docker-compose.yml con el siguiente contenido:</p> <p></p> <p>Con el archivo docker-compose.yml creado, se levantar\u00e1n los contenedores y se comprobar\u00e1 que funcionan correctamente.</p> <p></p> <p>Si accedemos a la direcci\u00f3n http://tu-ip:8082 deber\u00e1 aparecer la siguiente pantalla:</p> <p></p> <p>Introducimos las credenciales que usamos anteriormente. Usuario <code>customuser</code> y contrase\u00f1a <code>custompassword</code> en este caso.</p> <p></p>"},{"location":"PRACTICA6-3/#despliegue-con-docker-de-php-apache-con-autenticacion-ldap","title":"Despliegue con Docker de PHP + Apache con autenticaci\u00f3n LDAP","text":"<p>Ahora modificaremos el archivo index.php con el siguiente contenido:</p> <pre><code>&lt;?php\necho 'Ey, hola usuario autenticado por LDAP!';\n?&gt;\n</code></pre> <p></p> <p>Luego, modificamos el archivo Dockerfile del directorio Docker, donde los espacios se cambiar\u00e1n por los comandos pertinentes:</p> <pre><code>    ./Docker/Dockerfile --&gt; directorio donde se encuentra este archivo\n\n    Imagen base sobre la que vamos a trabajar\n    ____ php:7-apache\n\n    Activamos el m\u00f3dulo LDAP de Apache ejecutand el siguiente comando\n    ____ a2enmod authnz_ldap\n\n    A\u00f1adimos las reglas/configuraci\u00f3n de LDAP al directorio conf-enabled de Apache\n    (crearemos este archivo en el siguiente paso)\n    ____ Docker/ldap-demo.conf /etc/apache2/conf-enabled/\n\n    A\u00f1adimos ayuda de depuraci\u00f3n (debugging) en la configuraci\u00f3n de apache\n    En caso de necesitarlo, lo descomentamos para ejecutar el siguiente comando\n    ____ echo \"LogLevel debug\" &gt;&gt; apache2.conf\n\n    Establecemos el directorio de trabajo adecuado\n    ____ /var/www/html/demo\n\n\n    Configuramos Apache para usar la configuraci\u00f3n ldap definida arriba, la copiamos de nuestro ordenador al contenedor\n    ____ Docker/.htaccess ./.htaccess\n\n    Copiamos los archivos del proyecto que necesitamos, al contenedor\n\n    ____ index.php ./\n</code></pre> <p>Tambi\u00e9n modificamos el archivo ldap-demo.conf en Docker:</p> <pre><code>        ./Docker/ldap-demo.conf\n        PassEnv LDAP_BIND_ON\n        PassEnv LDAP_PASSWORD\n        PassEnv LDAP_URL\n        &lt;AuthnProviderAlias ldap demo&gt;\n            AuthLDAPBindDN ${LDAP_BIND_ON}\n            AuthLDAPBindPassword ${LDAP_PASSWORD}\n            AuthLDAPURL ${LDAP_URL}\n        &lt;/AuthnProviderAlias&gt;\n</code></pre> <p></p> <p></p> <p>Y el archivo htaccess se modificar\u00e1 con lo siguiente:</p> <pre><code>    cat &lt;&lt; EOF &gt; Docker/.htaccess\n    AuthBasicProvider demo\n    AuthType Basic\n    AuthName \"Protected Area\"\n    Require valid-user\n    EOF\n</code></pre> <p></p> <p></p> <p>Si todo ha salido bien hasta ahora, se podr\u00e1 ejecutar el siguiente comando para construir una imagen:</p> <p><code>sudo docker build . -t docker-ldap -f ./Docker/Dockerfile</code></p> <p></p> <p>Y si tambi\u00e9n ha salido bien, ejecutaremos un comando para levantar el contenedor pertinente:</p> <p>sudo docker run -p 3000:80 --name ldap_demo \\     -e LDAP_BIND_ON=\"uid=admin,cn=users,cn=accounts,dc=demo1,dc=freeipa,dc=org\" \\     -e LDAP_PASSWORD=\"Secret123\" \\     -e LDAP_URL=\"LDAP://ipa.demo1.freeipa.org\" \\     docker-ldap</p> <p></p> <p>Por \u00faltimo comprobamos que si entramos en la direcci\u00f3n http://nuestra-ip:8082/demo, deber\u00eda preguntarnos para iniciar sesi\u00f3n, entrando esta vez con usuario <code>admin</code> y contrase\u00f1a <code>Secret123</code>.</p> <p></p> <p></p> <p>Y con ello, se acaba la pr\u00e1ctica.</p>"}]}